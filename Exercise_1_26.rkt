#lang racket

;У Хьюго Дума большие трудности в упражнении 1.24. Процедура fast-prime? у него работает медленнее,
; чем prime?. Хьюго просит помощи у своей знакомой Евы Лу Атор. Вместе изучая код Хьюго, они обнаруживают,
; что тот переписал процедуру expmod с явным использованием умножения вместо того, чтобы вызывать square:
;(define (expmod base exp m)
;  (cond ((= exp 0) 1)
;        ((even? exp)
;         (remainder (* (expmod base (/ exp 2) m)
;                       (expmod base (/ exp 2) m)) m))
;        (else
;         (remainder (* base (expmod base (- exp 1) m))
;                    m))))
;Хьюго говорит: «Я не вижу здесь никакой разницы». «Зато я вижу, — отвечает Ева. — Переписав процедуру
; таким образом, ты превратил процесс порядка Θ(log n) в процесс порядка Θ(n)». Объясните.

; Как видим из определения функции expmod при четных числах exp уже должно вычислить две функции expmod
; для одинаковых аргументов. И так каждый раз при четных числах exp пораждается дополнительная
; ветка вычисления, которая в результате выдаст одинаковый результат. Порождается древовидный рекурсивный процесс,
; который требует больше количество число шагов и используемой памяти для вычислений, то есть процесс порядка Θ(n). 
; 
