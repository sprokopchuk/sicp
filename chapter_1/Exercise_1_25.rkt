#lang racket

(require rackunit)
(require math/number-theory)
(require math/base)
;Лиза П. Хакер жалуется, что при написании expmod мы делаем много лишней работы.
;В конце концов, говорит она, раз мы уже знаем, как вычислять степени, можно просто написать
;(define (expmod base exp m)
;  (remainder (fast-expt base exp) m))
;Права ли она? Стала бы эта процедура столь же хорошо работать при проверке простых чисел? Объясните.

(define (square a)(* a a))
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))


; Была такая функция
(define (expmod1 base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod1 base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod1 base (- exp 1) m))
                    m))))

; Переписали с использованием функции для вычисления степени
(define (expmod2 base exp m)
  (remainder (fast-expt base exp) m))

; Хоть функции expmod1 и expmod2 имеют одинаковое количество шагов вычисления,
; но они имеют разную ээфективность при вычислении больших чисел.  
; При малых числах expmod2 нормально будет вычисляться.
; Но когда степень и основание становяться большиыми числами, например больше 100000,
; время вычисления возвдения в степень таких чисел занимает длительное время, и в конце вычисляется остаток от числа.
; Поэтому expmod2 неээфективна.
; При вычислении функции expmod1 с помощью функции remainder оперируемые числа остаются по порядку равны
; степени и основанию.    